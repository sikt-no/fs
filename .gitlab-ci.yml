include:
  - component: $CI_SERVER_FQDN/platon/ci-components/docker/docker@2
  - component: $CI_SERVER_FQDN/platon/ci-components/deploy/deploy@1

variables:
  KUBE_PROD_DOMAIN: fs-funksjonelltesting.sokrates.edupaas.no
  KUBE_TEST_ID: fs-funksjonelltesting
  HTTP_PORT: '80'
  REPLICAS: '1'
  # Test environment variables
  GRAPHQL_ENDPOINT: https://supergraf-gateway-apollo-functionaltest.sokrates.edupaas.no/graphql
  FS_ADMIN_GRAPHQL: https://studieadm-fs-admin-functionaltest.sokrates.edupaas.no/api/graphql
  FS_ADMIN_URL: ${FS_ADMIN_URL:-https://studieadm-fs-admin-functionaltest.sokrates.edupaas.no}
  MIN_KOMPETANSE_URL: https://minkompetanse-functionaltest.sokrates.edupaas.no/nb
  FS_ADMIN_USERNAME: kari456staff
  FS_ADMIN_PASSWORD: 098asd
  FS_ADMIN_OVERSTYRT_BRUKER: "11906698511:970 422 528"
  BDD_TAGS: '@ci'

stages:
  - test
  - build
  - production

e2e_tests:
  stage: test
  image: mcr.microsoft.com/playwright:v1.57.0-noble
  before_script:
    - cd tester
    - apt-get update && apt-get install -y default-jre curl unzip gettext-base jq
    - npm ci
    # Fetch Allure history from previous successful pipeline for trend graphs.
    # Allure retains max 20 runs of history data for displaying test trends over time.
    # Validering sikrer at vi kun kopierer gyldig history og logger status for debugging.
    - mkdir -p allure-results
    - |
      if curl --location --output history.zip \
        "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/jobs/artifacts/main/download?job=e2e_tests&job_token=${CI_JOB_TOKEN}"; then
        unzip -o history.zip -d previous
        if [ -d previous/tester/allure-report/history ]; then
          cp -r previous/tester/allure-report/history allure-results/history
          echo "‚úì History loaded from previous run ($(ls -1 allure-results/history | wc -l) files)"
        else
          echo "‚ö† No history folder in previous artifacts"
        fi
      else
        echo "‚Ñπ No previous artifacts found, starting fresh"
      fi
  script:
    - npm test || true
    - npx allure generate allure-results -o allure-report --clean
  after_script:
    - cd tester
    - |
      # Extract test metrics from Playwright JSON results
      RESULTS_FILE="test-results/results.json"

      if [ -f "$RESULTS_FILE" ]; then
        # Parse JSON with jq
        export TEST_PASSED=$(jq -r '.stats.expected // 0' "$RESULTS_FILE")
        export TEST_FAILED=$(jq -r '.stats.unexpected // 0' "$RESULTS_FILE")
        export TEST_SKIPPED=$(jq -r '.stats.skipped // 0' "$RESULTS_FILE")
        export TEST_TOTAL=$((TEST_PASSED + TEST_FAILED + TEST_SKIPPED))

        # Duration in seconds (convert from milliseconds)
        TEST_DURATION_MS=$(jq -r '.stats.duration // 0' "$RESULTS_FILE")
        export TEST_DURATION=$(awk "BEGIN {printf \"%.1f\", $TEST_DURATION_MS / 1000}")

        # Extract first failed test if any failures exist
        if [ "$TEST_FAILED" -gt 0 ]; then
          # Find spec title for first failed test (recursive search through nested structure)
          export FIRST_FAILED_TEST=$(jq -r '.. | objects | select(.specs?) | .specs[]? | select(.tests[].results[].status == "failed") | .title' "$RESULTS_FILE" | head -1)

          # Find error message from first failed result
          export FIRST_FAILURE_MESSAGE=$(jq -r '.. | objects | select(.status? == "failed") | .error.message? // empty' "$RESULTS_FILE" | head -1 | head -c 300)

          # Fallback if queries return empty
          if [ -z "$FIRST_FAILED_TEST" ]; then
            export FIRST_FAILED_TEST="Ukjent test"
          fi
          if [ -z "$FIRST_FAILURE_MESSAGE" ]; then
            export FIRST_FAILURE_MESSAGE="Se testrapportene for detaljer"
          fi

          # Categorize error based on error message pattern (matches Allure categories)
          if echo "$FIRST_FAILURE_MESSAGE" | grep -qi "ERR_NAME_NOT_RESOLVED\|ENOTFOUND\|getaddrinfo\|DNS"; then
            export FAILURE_CATEGORY="üåê DNS/Infrastruktur"
          elif echo "$FIRST_FAILURE_MESSAGE" | grep -qi "timeout\|timed out"; then
            export FAILURE_CATEGORY="‚è±Ô∏è Timeout"
          elif echo "$FIRST_FAILURE_MESSAGE" | grep -qi "auth\|login\|session\|token"; then
            export FAILURE_CATEGORY="üîê Authentication"
          elif echo "$FIRST_FAILURE_MESSAGE" | grep -qi "locator\|element\|selector\|not found\|no element"; then
            export FAILURE_CATEGORY="üîç Element"
          elif echo "$FIRST_FAILURE_MESSAGE" | grep -qi "5[0-9][0-9]\|network\|fetch\|request failed\|ECONNREFUSED"; then
            export FAILURE_CATEGORY="üî¥ Backend/Network"
          else
            export FAILURE_CATEGORY="‚ö†Ô∏è Testfeil"
          fi
        else
          export FIRST_FAILED_TEST="N/A"
          export FIRST_FAILURE_MESSAGE="N/A"
          export FAILURE_CATEGORY=""
        fi
      else
        # Fallback values if results.json not found
        export TEST_TOTAL=0
        export TEST_PASSED=0
        export TEST_FAILED=0
        export TEST_SKIPPED=0
        export TEST_DURATION="0.0"
        export FIRST_FAILED_TEST="Ukjent"
        export FIRST_FAILURE_MESSAGE="Se testrapportene for detaljer"
      fi

      # Select template based on test results
      if [ "$TEST_FAILED" -gt 0 ]; then
        TEMPLATE="slack-templates/failed.json"
      else
        TEMPLATE="slack-templates/passed.json"
      fi

      # Send to Slack
      envsubst < "$TEMPLATE" | curl -X POST -H 'Content-type: application/json' -d @- "$SLACK_WEBHOOK"
  timeout: 30m
  artifacts:
    paths:
      - tester/playwright-report/
      - tester/allure-report/
    reports:
      junit: tester/test-results/junit.xml
    # Lagrer artifacts kun ved suksess for √• beskytte Allure history mot korrupsjon.
    # Med 'npm test || true' vil testfeil ikke feile jobben, s√• rapporter lagres ved testfeil.
    # Kun pipeline-crashes (OOM, timeout, allure generate feiler) vil hindre lagring,
    # og i de tilfellene er artifacts ofte korrupte og kan √∏delegge Allure history permanent.
    when: on_success
    expire_in: 1 week
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"
    - if: $CI_PIPELINE_SOURCE == "web"
    - if: $CI_PIPELINE_SOURCE == "trigger"

build:
  extends: .platon-docker-build
  stage: build
  needs:
    - job: e2e_tests
      artifacts: true
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"
    - if: $CI_PIPELINE_SOURCE == "web"
    - if: $CI_PIPELINE_SOURCE == "trigger"

production:
  extends: .production
  stage: production
  needs:
    - job: build
  script:
    - deploy deployment.yaml
  when: on_success
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"
    - if: $CI_PIPELINE_SOURCE == "web"
    - if: $CI_PIPELINE_SOURCE == "trigger"

stop_production:
  extends: .stop_production
  stage: production
