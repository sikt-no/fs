include:
  - component: $CI_SERVER_FQDN/platon/ci-components/docker/docker@2
  - component: $CI_SERVER_FQDN/platon/ci-components/deploy/deploy@1

variables:
  KUBE_PROD_DOMAIN: fs-funksjonelltesting.sokrates.edupaas.no
  KUBE_TEST_ID: fs-funksjonelltesting
  HTTP_PORT: '80'
  REPLICAS: '1'

  # User-configurable variables (set when triggering pipeline)
  TEST_ENV: "functionaltest"  # Options: "test" or "functionaltest"
  BDD_TAGS: "@ci"

  # Credentials (same for both environments)
  FS_ADMIN_USERNAME: kari456staff
  FS_ADMIN_PASSWORD: 098asd
  FS_ADMIN_OVERSTYRT_BRUKER: "11906698511:970 422 528"

stages:
  - test
  - build
  - production

e2e_tests:
  stage: test
  image: mcr.microsoft.com/playwright:v1.57.0-noble
  before_script:
    - cd tester
    - apt-get update && apt-get install -y default-jre curl unzip gettext-base jq
    - npm ci
    # Generate report timestamp (used for Slack links and report organization)
    - export REPORT_TIMESTAMP=$(date +%Y-%m-%d_%H-%M-%S)
    - echo "$REPORT_TIMESTAMP" > report-timestamp.txt
    # Set URLs based on TEST_ENV and write to env file for persistence
    - |
      if [ "$TEST_ENV" = "test" ]; then
        cat > /tmp/test-env.sh << ENVEOF
      export FS_ADMIN_URL="https://test-fsadmin.sikt.no"
      export FS_ADMIN_GRAPHQL="https://test-fsadmin.sikt.no/api/graphql"
      export MIN_KOMPETANSE_URL="https://test.minkompetanse.no/nb"
      export GRAPHQL_ENDPOINT="https://supergraf-gateway-apollo-test.sokrates.edupaas.no/graphql"
      export REPORT_TIMESTAMP="$REPORT_TIMESTAMP"
      ENVEOF
      else
        cat > /tmp/test-env.sh << ENVEOF
      export FS_ADMIN_URL="https://studieadm-fs-admin-functionaltest.sokrates.edupaas.no"
      export FS_ADMIN_GRAPHQL="https://studieadm-fs-admin-functionaltest.sokrates.edupaas.no/api/graphql"
      export MIN_KOMPETANSE_URL="https://minkompetanse-functionaltest.sokrates.edupaas.no/nb"
      export GRAPHQL_ENDPOINT="https://supergraf-gateway-apollo-functionaltest.sokrates.edupaas.no/graphql"
      export REPORT_TIMESTAMP="$REPORT_TIMESTAMP"
      ENVEOF
      fi
      source /tmp/test-env.sh
      echo "Using TEST_ENV=$TEST_ENV"
      echo "FS_ADMIN_URL=$FS_ADMIN_URL"
      echo "REPORT_TIMESTAMP=$REPORT_TIMESTAMP"
    # Fetch history from previous successful pipeline
    - mkdir -p allure-results
    - |
      curl --location --output history.zip \
        "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/jobs/artifacts/main/download?job=e2e_tests&job_token=${CI_JOB_TOKEN}" \
        && unzip -o history.zip -d previous \
        && cp -r previous/tester/allure-report/history allure-results/history \
        || echo "No previous history found, starting fresh"
  script:
    - source /tmp/test-env.sh
    - npm test || true
    - npx allure generate allure-results -o allure-report --clean
  after_script:
    - cd tester
    - source /tmp/test-env.sh
    - |
      # Extract test metrics from Playwright JSON results
      RESULTS_FILE="test-results/results.json"

      if [ -f "$RESULTS_FILE" ]; then
        # Parse JSON with jq
        export TEST_PASSED=$(jq -r '.stats.expected // 0' "$RESULTS_FILE")
        export TEST_FAILED=$(jq -r '.stats.unexpected // 0' "$RESULTS_FILE")
        export TEST_SKIPPED=$(jq -r '.stats.skipped // 0' "$RESULTS_FILE")
        export TEST_TOTAL=$((TEST_PASSED + TEST_FAILED + TEST_SKIPPED))

        # Duration in seconds (convert from milliseconds)
        TEST_DURATION_MS=$(jq -r '.stats.duration // 0' "$RESULTS_FILE")
        export TEST_DURATION=$(awk "BEGIN {printf \"%.1f\", $TEST_DURATION_MS / 1000}")

        # Extract first failed test if any failures exist
        if [ "$TEST_FAILED" -gt 0 ]; then
          # Find spec title for first failed test (recursive search through nested structure)
          export FIRST_FAILED_TEST=$(jq -r '.. | objects | select(.specs?) | .specs[]? | select(.tests[].results[].status == "failed") | .title' "$RESULTS_FILE" | head -1)

          # Find error message from first failed result
          export FIRST_FAILURE_MESSAGE=$(jq -r '.. | objects | select(.status? == "failed") | .error.message? // empty' "$RESULTS_FILE" | head -1 | head -c 300)

          # Fallback if queries return empty
          if [ -z "$FIRST_FAILED_TEST" ]; then
            export FIRST_FAILED_TEST="Ukjent test"
          fi
          if [ -z "$FIRST_FAILURE_MESSAGE" ]; then
            export FIRST_FAILURE_MESSAGE="Se testrapportene for detaljer"
          fi

          # Categorize error based on error message pattern (matches Allure categories)
          if echo "$FIRST_FAILURE_MESSAGE" | grep -qi "ERR_NAME_NOT_RESOLVED\|ENOTFOUND\|getaddrinfo\|DNS"; then
            export FAILURE_CATEGORY="ğŸŒ DNS/Infrastruktur"
          elif echo "$FIRST_FAILURE_MESSAGE" | grep -qi "timeout\|timed out"; then
            export FAILURE_CATEGORY="â±ï¸ Timeout"
          elif echo "$FIRST_FAILURE_MESSAGE" | grep -qi "auth\|login\|session\|token"; then
            export FAILURE_CATEGORY="ğŸ” Authentication"
          elif echo "$FIRST_FAILURE_MESSAGE" | grep -qi "locator\|element\|selector\|not found\|no element"; then
            export FAILURE_CATEGORY="ğŸ” Element"
          elif echo "$FIRST_FAILURE_MESSAGE" | grep -qi "5[0-9][0-9]\|network\|fetch\|request failed\|ECONNREFUSED"; then
            export FAILURE_CATEGORY="ğŸ”´ Backend/Network"
          else
            export FAILURE_CATEGORY="âš ï¸ Testfeil"
          fi
        else
          export FIRST_FAILED_TEST="N/A"
          export FIRST_FAILURE_MESSAGE="N/A"
          export FAILURE_CATEGORY=""
        fi
      else
        # Fallback values if results.json not found
        export TEST_TOTAL=0
        export TEST_PASSED=0
        export TEST_FAILED=0
        export TEST_SKIPPED=0
        export TEST_DURATION="0.0"
        export FIRST_FAILED_TEST="Ukjent"
        export FIRST_FAILURE_MESSAGE="Se testrapportene for detaljer"
      fi

      # Select template based on test results
      if [ "$TEST_FAILED" -gt 0 ]; then
        TEMPLATE="slack-templates/failed.json"
      else
        TEMPLATE="slack-templates/passed.json"
      fi

      # Send to Slack
      envsubst < "$TEMPLATE" | curl -X POST -H 'Content-type: application/json' -d @- "$SLACK_WEBHOOK"
  timeout: 30m
  artifacts:
    paths:
      - tester/playwright-report/
      - tester/allure-report/
      - tester/report-timestamp.txt
    reports:
      junit: tester/test-results/junit.xml
    when: always
    expire_in: 1 week
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"
    - if: $CI_PIPELINE_SOURCE == "web"
    - if: $CI_PIPELINE_SOURCE == "trigger"

build:
  extends: .platon-docker-build
  stage: build
  needs:
    - job: e2e_tests
      artifacts: true
  before_script:
    - export REPORT_TIMESTAMP=$(cat tester/report-timestamp.txt)
    - ./scripts/organize-reports.sh reports tester/playwright-report tester/allure-report "$REPORT_TIMESTAMP"
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"
    - if: $CI_PIPELINE_SOURCE == "web"
    - if: $CI_PIPELINE_SOURCE == "trigger"

production:
  extends: .production
  stage: production
  needs:
    - job: build
  script:
    - deploy deployment.yaml
  when: on_success
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"
    - if: $CI_PIPELINE_SOURCE == "web"
    - if: $CI_PIPELINE_SOURCE == "trigger"

stop_production:
  extends: .stop_production
  stage: production
