#!/bin/bash
# Extract test metrics from Playwright JSON results and generate Slack payload
# Exports variables used by Slack templates (via envsubst)
# Saves payload to slack-payload.json (sent later by production job)
# Usage: Called from e2e_tests after_script (after tests complete)

set -e

# Working directory should be tester/ (set by after_script: cd tester)
# Source environment variables (TEST_ENV, URLs, REPORT_TIMESTAMP)
# shellcheck disable=SC1091  # File is generated by setup-test-env.sh
source /tmp/test-env.sh

# Extract test metrics from Playwright JSON results
RESULTS_FILE="test-results/results.json"

if [ -f "$RESULTS_FILE" ]; then
  # Parse JSON with jq
  export TEST_PASSED
  TEST_PASSED=$(jq -r '.stats.expected // 0' "$RESULTS_FILE")
  export TEST_FAILED
  TEST_FAILED=$(jq -r '.stats.unexpected // 0' "$RESULTS_FILE")
  export TEST_SKIPPED
  TEST_SKIPPED=$(jq -r '.stats.skipped // 0' "$RESULTS_FILE")
  export TEST_TOTAL=$((TEST_PASSED + TEST_FAILED + TEST_SKIPPED))

  # Duration in seconds (convert from milliseconds)
  TEST_DURATION_MS=$(jq -r '.stats.duration // 0' "$RESULTS_FILE")
  export TEST_DURATION
  TEST_DURATION=$(awk "BEGIN {printf \"%.1f\", $TEST_DURATION_MS / 1000}")

  # Extract first failed test if any failures exist
  if [ "$TEST_FAILED" -gt 0 ]; then
    # Find spec title for first failed test (recursive search through nested structure)
    export FIRST_FAILED_TEST
    FIRST_FAILED_TEST=$(jq -r '.. | objects | select(.specs?) | .specs[]? | select(.tests[].results[].status == "failed") | .title' "$RESULTS_FILE" | head -1)

    # Find error message from first failed result
    export FIRST_FAILURE_MESSAGE
    FIRST_FAILURE_MESSAGE=$(jq -r '.. | objects | select(.status? == "failed") | .error.message? // empty' "$RESULTS_FILE" | head -1 | head -c 300)

    # Fallback if queries return empty
    if [ -z "$FIRST_FAILED_TEST" ]; then
      export FIRST_FAILED_TEST="Ukjent test"
    fi
    if [ -z "$FIRST_FAILURE_MESSAGE" ]; then
      export FIRST_FAILURE_MESSAGE="Se testrapportene for detaljer"
    fi

    # Categorize error based on error message pattern (matches Allure categories)
    if echo "$FIRST_FAILURE_MESSAGE" | grep -qi "ERR_NAME_NOT_RESOLVED\|ENOTFOUND\|getaddrinfo\|DNS"; then
      export FAILURE_CATEGORY="üåê DNS/Infrastruktur"
    elif echo "$FIRST_FAILURE_MESSAGE" | grep -qi "timeout\|timed out"; then
      export FAILURE_CATEGORY="‚è±Ô∏è Timeout"
    elif echo "$FIRST_FAILURE_MESSAGE" | grep -qi "auth\|login\|session\|token"; then
      export FAILURE_CATEGORY="üîê Authentication"
    elif echo "$FIRST_FAILURE_MESSAGE" | grep -qi "locator\|element\|selector\|not found\|no element"; then
      export FAILURE_CATEGORY="üîç Element"
    elif echo "$FIRST_FAILURE_MESSAGE" | grep -qi "5[0-9][0-9]\|network\|fetch\|request failed\|ECONNREFUSED"; then
      export FAILURE_CATEGORY="üî¥ Backend/Network"
    else
      export FAILURE_CATEGORY="‚ö†Ô∏è Testfeil"
    fi
  else
    export FIRST_FAILED_TEST="N/A"
    export FIRST_FAILURE_MESSAGE="N/A"
    export FAILURE_CATEGORY=""
  fi
else
  # Fallback values if results.json not found
  export TEST_TOTAL=0
  export TEST_PASSED=0
  export TEST_FAILED=0
  export TEST_SKIPPED=0
  export TEST_DURATION="0.0"
  export FIRST_FAILED_TEST="Ukjent"
  export FIRST_FAILURE_MESSAGE="Se testrapportene for detaljer"
  export FAILURE_CATEGORY=""
fi

# Select template based on test results
if [ "$TEST_FAILED" -gt 0 ]; then
  TEMPLATE="slack-templates/failed.json"
else
  TEMPLATE="slack-templates/passed.json"
fi

# Save Slack payload to file (will be sent after deploy by production job)
envsubst < "$TEMPLATE" > slack-payload.json
